### 1. .NET REFLECTION
---
- What is it?
    > - .NET object의 class type, method, property 등의 meta 정보를 run-time 중에 알아내는 기능.
    > - 이러한 meta 정보를 통해, 직접 method 호출 또는 property 변경이 가능하다.
- 활용 예
    > - 동적으로 코드확장이 필요한 경우.
    > - 테스트용 메소드들을 호출하는 경우.
    > - 특정 class 안에 지정된 이름의 member가 있는지 판단하는 경우.
    > - Object dumping.
    > - Weaving
    > - JSON serializer
    > - C# Attribute 활용
    > - ...


　

### 2. .NET REFLECTION을 이용한 조회
---
- 활용 예
    ```
    using System;
    using System.Reflection;
    
    class Program
    {
    static void PrintInterfaces(Type type)
    {
        Console.WriteLine("------ Interfaces ------");
    
        Type[] interfaces = type.GetInterfaces();
        foreach (Type i in interfaces)
        Console.WriteLine("Name:{0}", i.Name);
    
        Console.WriteLine();
    }
    
    static void PrintFields(Type type)
    {
        Console.WriteLine("------ Fields ------");
    
        FieldInfo[] fields = type.GetFields(
        BindingFlags.NonPublic |
        BindingFlags.Public |
        BindingFlags.Static |
        BindingFlags.Instance);
    
        foreach (FieldInfo field in fields)
        {
        String accessLevel;
    
        if (field.IsPublic)
            accessLevel = "public";
        else if (field.IsPrivate)
            accessLevel = "private";
        else
            accessLevel = "protected";
    
        Console.WriteLine(
            "Access:{0}, Type:{1}, Name:{2}",
            accessLevel,
            field.FieldType.Name,
            field.Name);
        }
    
        Console.WriteLine();
    }
    
    static void PrintMethods(Type type)
    {
        Console.WriteLine("------ Method ------");
    
        MethodInfo[] methods = type.GetMethods();
        foreach (MethodInfo method in methods)
        {
        Console.Write(
            "Type:{0}, Name:{1}, Parameter:",
            method.ReturnType.Name,
            method.Name);
    
        ParameterInfo[] args = method.GetParameters();
        for (int i = 0; i < args.Length; i++)
        {
            Console.Write("{0}", args[i].ParameterType.Name);
            if (i < args.Length - 1)
            Console.Write(", ");
        }
        Console.WriteLine();
        }
        Console.WriteLine();
    }
    
    static void PrintProperties(Type type)
    {
        Console.WriteLine("------ Properties ------");
    
        PropertyInfo[] properties = type.GetProperties();
        foreach (PropertyInfo property in properties)
        {
        Console.WriteLine(
            "Type:{0}, Name:{1}",
            property.PropertyType.Name,
            property.Name);
        }
        Console.WriteLine();
    }
    
    static void Main(string[] args)
    {
        int a = 0;
        Type type = a.GetType();
    
        PrintInterfaces(type);
        PrintFields(type);
        PrintProperties(type);
        PrintMethods(type);
    }
    }
    ```

- ***See Also***
    - [***C# 리플렉션, GetType 예제 코드***](https://morm.tistory.com/219)


　

3. .NET REFLECTION을 이용한 PROPERTY 설정
참고: .NET Reflection 1 - C# 프로그래밍 배우기 (Learn C# Programming)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
using System;
using System.Reflection;
 
class Program
{
    static void Main(string[] args)
    {
        MyClass my = new MyClass();
        SetDefaultName(my);
        Console.WriteLine(my.Name);
    }
 
    static void SetDefaultName(object obj)
    {
        PropertyInfo pi = obj.GetType().GetProperty("Name");
        if (pi != null)
        {
            Console.WriteLine("OLD: " + pi.GetValue(obj, null));
            pi.SetValue(obj, "Lee", null);
            Console.WriteLine("NEW: " + pi.GetValue(obj, null));
        }
    }
 
    class MyClass
    {
        public string Name
        {
            get; set;
        }
    }
}
"GetProperties" method를 통해 class의 모든 property를 가져올 수도 있다.


4. .NET REFLECTION을 이용한 METHOD 호출
참고: .NET Reflection 1 - C# 프로그래밍 배우기 (Learn C# Programming)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
using System;
using System.Reflection;
 
class Program
{
    static void Main(string[] args)
    {
        MyClass1 m1 = new MyClass1();
        MyClass2 m2 = new MyClass2();
        MyClass3 m3 = new MyClass3();
 
        MyFunc(m1);
        MyFunc(m2);
        MyFunc(m3);
    }
 
    static void MyFunc(object obj)
    {
        MethodInfo mi = obj.GetType().GetMethod("MyMethod");
        if (mi != null)
        {
            mi.Invoke(obj, null);
        }
        else
        {
            Console.WriteLine(
                obj.GetType().Name + ": MyMethod not found");
        }
    }
 
    class MyClass1
    {
        public void MyMethod()
        {
            Console.WriteLine("MyClass1.MyMethod");
        }
    }
 
    class MyClass2
    {
        public void MyMethod()
        {
            Console.WriteLine("MyClass2.MyMethod");
        }
    }
 
    class MyClass3
    {
        public void DifferentMethod()
        {
            Console.WriteLine("MyClass3.DifferentMethod");
        }
    }
}
모든 method 정보를 가져오기 위해서는 "GetMethods"를 호출한다.


5. .NET REFLECTION을 이용한 OBJECT INSTANCE 생성
참고: .NET Reflection 2 - C# 프로그래밍 배우기 (Learn C# Programming)
참고: C# 리플렉션 2 - 객체 생성 이용 (System.Activator 클래스)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
namespace MyNamespace
{
    using System;
 
    public class Program
    {
        static void Main(string[] args)
        {
            Type type = Type.GetType("MyNamespace.Customer");
            object obj = Activator.CreateInstance(type);
            Console.WriteLine(((Customer)obj).Name);
            type.GetMethod("Print").Invoke(obj, null);
        }
    }
 
    public class Customer
    {
        public Customer()
        {
            this.Name = "No name";
        }
 
        public int Id
        {
            get; set;
        }
 
        public string Name
        {
            get; set;
        }
 
        public void Print()
        {
            Console.WriteLine("{0}, {1}", Name, Id);
        }
    }
}
문자열로 instance를 생성할 수 있다는 것을 보여줌.
object instance로 type을 얻어낼 수도 있다.
　

6. GENERIC TYPE으로부터 OBJECT INSTANCE 생성
참고: .NET Reflection 2 - C# 프로그래밍 배우기 (Learn C# Programming)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
using System;
using System.Collections.Generic;
 
public class Program
{
  static void Main(string[] args)
  {
    MyFilter<int> filter = new MyFilter<int>();
    Run(filter);
  }
 
  static void Run(object filter)
  {
    if (filter.GetType().Name == typeof(MyFilter<>).Name)
    {
      Type T = filter.GetType().GetGenericArguments()[0];
      Type type = typeof(MyFilter<>).MakeGenericType(T);
      object obj = Activator.CreateInstance(type, true);
      Console.WriteLine(obj.GetType().Name);
    }
  }
}
 
public class MyFilter<T> where T : struct
{
  private List<T> elements;
 
  public MyFilter()
  {
    elements = new List<T>();
  }
 
  public MyFilter(List<T> elements)
  {
    this.elements = elements;
  }
}
class type이 정해지지 않은 generic type은 parameter T가 정해지지 않으면 Activator로 object를 생성할 수 없다. generic type 자체로는 class가 되지 못하기 때문.
"Assembly.CreateInstance"라는 것도 있는데, 이것은 해당 assembly에 있는 type object만을 생성할 수 있다. 하지만 "Activator.CreateInstance"는 다른 assembly에 있는 type의 object instance를 생성할 수 있다. 다른 assembly의 class 정보를 가져오기 위해서는 "GetType" 두 번째 인자에 assembly 이름을 추가로 입력해야 한다.
　

7. GENERIC METHOD 호출
"MakeGenericMethod" method를 사용하여 T를 지정한다.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
using System;
 
public class Program
{
  static void Main(string[] args)
  {
    var result =
      Type.GetType("MyFilter")
      .GetMethod("Test")
      .MakeGenericMethod(typeof(int))
      .Invoke(null, new object[] { 100 });
 
    Console.WriteLine(result);
  }
}
 
public class MyFilter
{
  public static T Test<T>(T number) where T : struct
  {
    Console.WriteLine(number);
    return number;
  }
}


