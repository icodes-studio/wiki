. C# 동적 컴파일(DYNAMIC COMPILATION)
참고: C# 동적 컴파일 - C# 프로그래밍 배우기 (Learn C# Programming)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
using System;
using System.CodeDom.Compiler;
using System.Diagnostics;
 
class Program
{
  static void Main(string[] args)
  {
    string code = @"
    using System;
    namespace TEST
    {
      class Program
      {
        static void Main(string[] args)
        {
          int sum = 0;
          for (int i = 0; i < 100; i++)
            sum += i;
 
          Console.WriteLine(sum);
          Console.ReadLine();
        }
      }
    }";
 
    var codeDom = CodeDomProvider.CreateProvider("CSharp");
    var results = codeDom.CompileAssemblyFromSource
    (
      new CompilerParameters()
      {
        GenerateExecutable = true,
        OutputAssembly = "TEST.EXE"
      },
      code
    );
 
    if (results.Errors.Count > 0)
    {
      foreach (var err in results.Errors)
        Console.WriteLine(err.ToString());
 
      return;
    }
 
    Process.Start("TEST.EXE");
  }
}
C# 코드를 compile해서 .EXE 나 .DLL 등을 build할 수 있다.
"CodeDomProvider.CreateProvider"로 특정 언어에 대한 compiler object 생성.
필요한 컴파일 옵션(eg. EXE or DLL) 지정.
"CompileAssemblyFromSource" 외에 파일로부터 컴파일하는 "CompileAssemblyFromFile", DOM 트리로부터 컴파일하는 "CompileAssemblyFromDom" 등이 있다.
　　

2. 동적 CLASS 생성과 사용 #1
참고: C# 동적 컴파일 - C# 프로그래밍 배우기 (Learn C# Programming)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
using System;
using System.CodeDom.Compiler;
using System.Reflection;
 
class Program
{
  static void Main(string[] args)
  {
    string code = @"
    using System;
    namespace Test
    {
      class MyClass
      {
        public string Name
        {
          get; set;
        }
        public void PrintName()
        {
          Console.WriteLine(Name);
        }
      }
    }";
 
    var codeDom = CodeDomProvider.CreateProvider("CSharp");
    var results = codeDom.CompileAssemblyFromSource
    (
      new CompilerParameters()
      {
        GenerateInMemory = true,
        //ReferencedAssemblies.Add("ThirdParty.dll")
      },
      code
    );
 
    if (results.Errors.Count > 0)
    {
      foreach (var err in results.Errors)
        Console.WriteLine(err.ToString());
 
      return;
    }
 
    Type type = results.CompiledAssembly.GetType("Test.MyClass");
    object obj = Activator.CreateInstance(type);
    PropertyInfo pi = obj.GetType().GetProperty("Name");
 
    pi.SetValue(obj, "Alex", null);
    object name = pi.GetValue(obj);
    Console.WriteLine(name);
 
    obj.GetType().GetMethod("PrintName").Invoke(obj, null);
  }
}
문자열로부터 C# 클래스를 생성하여 이를 memory상에 생성하고, 이 class로부터 object instance를 생성하고 그 속성과 method를 .NET Reflection을 이용하여 사용할 수 있다.
VB.NET 코드를 compile 하려면 "CSharp" 대신에 "VisualBasic"을 지정.
　

3. 동적 CLASS 생성과 사용 #2
참고: C# 동적 컴파일 - C# 프로그래밍 배우기 (Learn C# Programming)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
using System;
using System.CodeDom.Compiler;
using System.Reflection;
 
class Program
{
  static void Main(string[] args)
  {
    string code = @"
    using System;
    namespace TEST
    {
      class Program
      {
        static void Test()
        {
          int sum = 0;
          for (int i = 0; i < 100; i++)
            sum += i;
 
          Console.WriteLine(sum);
          Console.ReadLine();
        }
      }
    }";
 
    var codeDom = CodeDomProvider.CreateProvider("CSharp");
    var results = codeDom.CompileAssemblyFromSource
    (
      new CompilerParameters()
      {
          GenerateExecutable = false,
          OutputAssembly = "TEST.DLL"
      },
      code
    );
 
    if (results.Errors.Count > 0)
    {
      foreach (var err in results.Errors)
        Console.WriteLine(err.ToString());
 
      return;
    }
 
    Assembly
      .LoadFrom("TEST.DLL")
      .GetType("TEST.Program")
      .GetMethod("Test", BindingFlags.NonPublic | BindingFlags.Static)
      .Invoke(null, null);
  }
}
DLL로 저장하고...
DLL 파일을 직접 load하여 class를 사용할 수 있다.
겸사겸사 static method를 어떻게 접근하여 사용하는지 보여준다.
static method는 굳이 object instance를 생성할 필요가 없다.
　

4. ASSEMBLY DATA를 바로 LOAD하기
assembly data를 다운받아 file IO 없이 바로 사용하는데 응용할 수 있겠다.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
using System.IO;
using System.Reflection;
 
class Program
{
  static void Main(string[] args)
  {
    Assembly
      .Load(File.ReadAllBytes("TEST.DLL"))
      .GetType("TEST.Program")
      .GetMethod("Test", BindingFlags.NonPublic | BindingFlags.Static)
      .Invoke(null, null);
  }
}
assembly를 load, unload하는 방법은 아래 문서 참고
Assembly.Load Method
How to: Load Assemblies into an Application Domain
Best Practices for Assembly Loading
How to: Load and unload assemblies
Loading Assemblies using Assembly.Load, Assembly.LoadFrom and Assembly.LoadFile
DLL reload
다음 강의에서 AssemblyBuilder를 사용한 모듈 저장 방법도 소개 한다.
