1. DYNAMIC INVOCATION USING REFLECTION
참고: http://www.simpleisbest.net/archive/2007/05/09/1744.aspx

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
using System;
using System.Reflection;
 
class Program
{
  static void Main(string[] args)
  {
    string m = "FillStringChecked";
    string s = "The Original String";
    string c = "The Changed";
 
    Console.WriteLine(s);
 
    typeof(string)
    .GetMethod(m, BindingFlags.NonPublic | BindingFlags.Static)
    .Invoke(null, new object[] { s, 0, c });
 
    Console.WriteLine(s);
  }
}
reflection을 이용하여 string class의 internal member인 "FillStringChecked" static method를 호출하는 예제.
internal이 뭔진 다들 알지?
　

2. USING DYNAMIC METHOD
참고: http://www.simpleisbest.net/archive/2007/05/09/1744.aspx

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
using System;
using System.Reflection;
using System.Reflection.Emit;
 
class Program
{
  delegate void FillString(string d, int p, string s);
 
  static void Main(string[] args)
  {
    string m = "FillStringChecked";
    string s = "The Original String";
    string c = "The Changed";
 
    var dm = new DynamicMethod
    (
      "FillString",
      typeof(void),
      new Type[] { typeof(string), typeof(int), typeof(string) },
      typeof(Program).Module,
      true
    );
 
    var mi = typeof(string).GetMethod(m, BindingFlags.NonPublic | BindingFlags.Static);
    var il = dm.GetILGenerator();
 
    il.Emit(OpCodes.Ldarg_0);
    il.Emit(OpCodes.Ldarg_1);
    il.Emit(OpCodes.Ldarg_2);
    il.Emit(OpCodes.Call, mi);
    il.Emit(OpCodes.Ret);
 
    Console.WriteLine(s);
    ((FillString)dm.CreateDelegate(typeof(FillString)))(s, 0, c);
    Console.WriteLine(s);
  }
}
자, 드디어 등장! System.Reflection.Emit
dynamic method는 invoke method를 사용하는 것보다 성능이 훨씬 좋다.
ILGenerator를 사용해서 동적으로 IL 코드를 생성할 수 있다.
OpCodes
Ldarg_0 : index 0에 있는 argument를 evaluation stack으로 load.
Ldarg_1 : index 1에 있는 argument를 evaluation stack으로 load.
Ldarg_2 : index 2에 있는 argument를 evaluation stack으로 load.
Call : 인자로 넘긴 method를 호출.
Ret : 현재 method에서 제어를 반환하고, 반환값이 있을 경우 반환값을 calli의 evaluation stack에서 caller의 evaluation stack으로 push.
결국 아래 코드를 생성하고 호출한 셈이다.

1
2
3
4
static void FillString(string arg1, int arg2, string arg3)
{
    String.FillStringChecked(arg1, arg2, arg3);
}
　

3. 동적으로 새로운 TYPE 만들기
참고: https://m.blog.naver.com/go4693/221308787518

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
using System;
using System.Reflection;
using System.Reflection.Emit;
 
class Program
{
  static void Main(string[] args)
  {
    var name = new AssemblyName("CalculatorAssembly");
    var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
    var module = assembly.DefineDynamicModule("Calculator");
    var type = module.DefineType("Sum3");
    var method = type.DefineMethod("Calculate", MethodAttributes.Public, typeof(int), new Type[0]);
    var il = method.GetILGenerator();
 
    il.Emit(OpCodes.Ldc_I4, 1);
    il.Emit(OpCodes.Ldc_I4, 2);
    il.Emit(OpCodes.Add);
    il.Emit(OpCodes.Ldc_I4, 3);
    il.Emit(OpCodes.Add);
    il.Emit(OpCodes.Ret);
 
    var dynamicType = type.CreateType();
    var instance = Activator.CreateInstance(dynamicType);
    MethodInfo calculate = instance.GetType().GetMethod("Calculate");
    Console.WriteLine(calculate.Invoke(instance, null));
  }
}
"AssemblyBuilder"로 assembly를 만든다.
"ModuleBuilder"로 assembly 안에 module을 만든다.
"TypeBuilder"로 module 안에 type(class)을 만든다.
"MethodBuilder"로 class 안에 method 껍데기를 만듬.
"ILGenerator"로 method 안에 실행될 IL 명령을 넣는다.
Ldc_I4 : Int32를 evaluation stack에 push
Add : stack에서 두개 pop해서 더한후 push
Ret : stack에서 한 개 pop해서 caller에게 return
결국 아래의 C# 코드를 만들어낸 것임.

1
2
3
4
5
6
7
class Sum3
{
    public int Calculate()
    {
        return 1 + 2 + 3;
    }
}
　

4. 생성한 IL코드 살펴보기
참고: https://stackoverflow.com/questions/4146877/how-do-i-get-an-il-bytearray-from-a-dynamicmethod

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
using System;
using System.Reflection;
using System.Reflection.Emit;
 
class Program
{
  static void Main(string[] args)
  {
    var name = new AssemblyName("CalculatorAssembly");
    var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
    var module = assembly.DefineDynamicModule("Calculator");
    var type = module.DefineType("Sum3");
    var method = type.DefineMethod("Calculate", MethodAttributes.Public, typeof(int), new Type[0]);
    var il = method.GetILGenerator();
 
    il.Emit(OpCodes.Ldc_I4, 1);
    il.Emit(OpCodes.Ldc_I4, 2);
    il.Emit(OpCodes.Add);
    il.Emit(OpCodes.Ldc_I4, 3);
    il.Emit(OpCodes.Add);
    il.Emit(OpCodes.Ret);
 
    PrintIL1(il);
    PrintIL2(il);
  }
 
  static void PrintIL1(ILGenerator il)
  {
    Console.WriteLine("IL CODE - BakeByteArray");
 
    byte[] codes =
      il.GetType()
        .GetMethod("BakeByteArray", BindingFlags.NonPublic | BindingFlags.Instance)
        .Invoke(il, null) as byte[];
 
    foreach (byte code in codes)
      Console.WriteLine("0x{0:X}, ", code);
  }
 
  static void PrintIL2(ILGenerator il)
  {
    Console.WriteLine("IL CODE - m_lStream");
 
    byte[] codes =
      il.GetType()
        .GetField("m_ILStream", BindingFlags.Instance | BindingFlags.NonPublic)
        .GetValue(il) as byte[];
 
    int length = (int)
      il.GetType()
        .GetField("m_length", BindingFlags.Instance | BindingFlags.NonPublic)
        .GetValue(il);
 
    for (int i = 0; i < length; ++i)
      Console.WriteLine("0x{0:X}, ", codes[i]);
  }
}
ILGenerator는 생성한 IL byte code를 반환하는 공식 interface가 없다.
하지만 우리는 이제 .NET reflection을 이용하여 숨겨져 있는 method와 field를 꺼내 호출하거나 조회 할수 있게되었다.
물론, 위 코드는 MS .NET Framework에서만 동작한다.
Mono .NET에서는 동작하지 않는다. 내부 구현이 다르기 때문이며 타겟 프레임워크 버전과 소스 코드를 참고하여 대응해야 한다.
참고: MS .NET 소스 - GITHUB
참고: MS .NET 소스 - MICROSOFT
참고: Mono .NET 소스 - GITHUB
아무튼 조회한 IL byte code를 정리하면 아래 모습이다.

0x20, 0x1, 0x0, 0x0, 0x0, // il.Emit(OpCodes.Ldc_I4, 1)
0x20, 0x2, 0x0, 0x0, 0x0, // il.Emit(OpCodes.Ldc_I4, 2)
0x58,                     // il.Emit(OpCodes.Add);
0x20, 0x3, 0x0, 0x0, 0x0, // il.Emit(OpCodes.Ldc_I4, 3)
0x58,                     // il.Emit(OpCodes.Add)
0x2A,                     // il.Emit(OpCodes.Ret)
구현에 사용된 instruction들과 1:1 대응됨을 볼 수 있다.
참고: OpCodes.Ldc_I4 Format Value
　

5. IL BYTE 코드로 METHOD BODY 만들기
참고: https://stackoverflow.com/questions/26312026/execute-net-il-code-in-c-sharp

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
using System;
using System.Reflection;
using System.Reflection.Emit;
 
class Program
{
  static void Main(string[] args)
  {
    var name = new AssemblyName("CalculatorAssembly");
    var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
    var module = assembly.DefineDynamicModule("Calculator");
    var type = module.DefineType("Sum3");
    var method = type.DefineMethod("Calculate", MethodAttributes.Public, typeof(int), new Type[0]);
 
    byte[] code =
    {
      0x20, 0x1, 0x0, 0x0, 0x0, // il.Emit(OpCodes.Ldc_I4, 1);
      0x20, 0x2, 0x0, 0x0, 0x0, // il.Emit(OpCodes.Ldc_I4, 2);
      0x58,                     // il.Emit(OpCodes.Add);
      0x20, 0x3, 0x0, 0x0, 0x0, // il.Emit(OpCodes.Ldc_I4, 3);
      0x58,                     // il.Emit(OpCodes.Add);
      0x2A,                     // il.Emit(OpCodes.Ret);
    };
 
    method.CreateMethodBody(code, code.Length);
 
    var dynType = type.CreateType();
    var instance = Activator.CreateInstance(dynType);
    var dynMethod = dynType.GetMethod("Calculate");
    var calculate = (Func<int>)dynMethod.CreateDelegate(typeof(Func<int>), instance);
    Console.WriteLine(calculate());
  }
}
IL byte code는 method body를 구성하는데 사용할 수 있다.
이번에는 dynamic delegate를 생성하여 method를 호출해 보았다.
　

6. INSTANCE MEMBER를 가진 CLASS 만들기
참고: https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=netframework-4.8

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
using System;
using System.Reflection;
using System.Reflection.Emit;
 
class Program
{
  static void Main(string[] args)
  {
    var name = new AssemblyName("MyDynamicAssembly");
    var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
    var module = assembly.DefineDynamicModule("PointModule");
    var type = module.DefineType("Point", TypeAttributes.Public);
    var x = type.DefineField("x", typeof(int), FieldAttributes.Public);
    var y = type.DefineField("y", typeof(int), FieldAttributes.Public);
    var ctor = type.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, new Type[] { typeof(int), typeof(int) });
    var ctorIL = ctor.GetILGenerator();
    var ctorObject = Type.GetType("System.Object").GetConstructor(new Type[0]);
    var method = type.DefineMethod("WritePoint", MethodAttributes.Public, typeof(void), null);
    var methodIL = method.GetILGenerator();
 
    ctorIL.Emit(OpCodes.Ldarg_0);
    ctorIL.Emit(OpCodes.Call, ctorObject);
    ctorIL.Emit(OpCodes.Ldarg_0);
    ctorIL.Emit(OpCodes.Ldarg_1);
    ctorIL.Emit(OpCodes.Stfld, x);
    ctorIL.Emit(OpCodes.Ldarg_0);
    ctorIL.Emit(OpCodes.Ldarg_2);
    ctorIL.Emit(OpCodes.Stfld, y);
    ctorIL.Emit(OpCodes.Ret);
 
    MethodInfo writeLine =
      typeof(Console).GetMethod("WriteLine", new Type []
      {
        typeof(string),
        typeof(object),
        typeof(object)
      });
 
    methodIL.EmitWriteLine("The value of this current instance is:");
    methodIL.Emit(OpCodes.Ldstr, "({0}, {1})");
    methodIL.Emit(OpCodes.Ldarg_0);
    methodIL.Emit(OpCodes.Ldfld, x);
    methodIL.Emit(OpCodes.Box, typeof(int));
    methodIL.Emit(OpCodes.Ldarg_0);
    methodIL.Emit(OpCodes.Ldfld, y);
    methodIL.Emit(OpCodes.Box, typeof(int));
    methodIL.Emit(OpCodes.Call, writeLine);
    methodIL.EmitWriteLine("The value of 'x' is:");
    methodIL.EmitWriteLine(x);
    methodIL.EmitWriteLine("The value of 'y' is:");
    methodIL.EmitWriteLine(y);
    methodIL.Emit(OpCodes.Ret);
 
    var dynType = type.CreateType();
    dynType.InvokeMember
    (
      "WritePoint",
      BindingFlags.InvokeMethod,
      null,
      Activator.CreateInstance(dynType, new object[] { 100, 200 }),
      new object[0]
    );
  }
}
this member를 어떻게 접근하고 있는지 보여준다.
base class를 어떻게 호출하고 있는지 보여준다.
member field를 어떻게 생성하고 사용하는지 보여준다.
결국 위 IL instruction은 아래의 코드를 만들어낸 것이다.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
using System;
 
public class Point : base()
{
  public int x;
  public int y;
 
  public Point(int x, int y)
  {
    this.x = x;
    this.y = y;
  }
 
  public void WritePoint()
  {
    Console.WriteLine("The value of this current instance is:");
    Console.WriteLine("({0}, {1})", x, y);
    Console.WriteLine("The value of 'x' is:");
    Console.WriteLine(x);
    Console.WriteLine("The value of 'y' is:");
    Console.WriteLine(y);
  }
}
　

7. ASSEMBLY 저장 및 LOAD
참고: https://cafe.naver.com/kusdoblee/71
참고: https://www.c-sharpcorner.com/uploadfile/puranindia/reflection-and-reflection-emit-in-C-Sharp/

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
// 6번 예제 재활용.
class Program
{
  static void Main(string[] args)
  {
    ...
    var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.RunAndSave);
    var module = assembly.DefineDynamicModule("PointModule", "MyDynamicAssembly.dll");
    ...
 
    assembly.Save("MyDynamicAssembly.dll");
 
    var myType = Assembly.Load("MyDynamicAssembly").GetType("Point");
    var instance = Activator.CreateInstance(myType, new Object[] { 100, 200 });
    myType.GetMethod("WritePoint").Invoke(instance, null);
  }
}
예전 강의에서 C# 코드를 런타임에 컴파일&저장 하는 것을 살펴보았다.
Reflection.Emit IL instruction으로 만든 dynamic type도 파일에 저장할 수 있다.
