### 5.1 OBJECT DUMPER
---
- 오브젝트 인스턴스의 내용을 출력하는 기능
  ```
  using System;
  using System.Collections;
  using System.Text;
  using System.Reflection;
  using System.Collections.Generic;

  class Program
  {
      static void Main(string[] args)
      {
          var test = new List<List<List<Test>>>
          {
              new List<List<Test>>
              {
                  new List<Test>
                  {
                      new Test(0, "John",    "000-111-222", new Test.HashCode("test01", 0)),
                      new Test(1, "Lee",     "000-111-222", new Test.HashCode("test02", 0)),
                      new Test(2, "Kwak",    "000-111-222", new Test.HashCode("test03", 0)),
                      new Test(3, "Smith",   "000-111-222", new Test.HashCode("test04", 0)),
                  },
                  new List<Test>
                  {
                      new Test(4, "Pak",     "000-111-222", new Test.HashCode("test05", 0)),
                      new Test(5, "Dorothy", "000-111-222", new Test.HashCode("test06", 0)),
                      new Test(6, "Kim",     "000-111-222", new Test.HashCode("test07", 0)),
                      new Test(7, "Unknown", "000-111-222", new Test.HashCode("test08", 0)),
                  }
              },
              new List<List<Test>>
              {
                  new List<Test>
                  {
                      new Test(0, "Hong",    "000-111-222", new Test.HashCode("test09", 0)),
                      new Test(1, "Choi",    "000-111-222", new Test.HashCode("test10", 0)),
                      new Test(2, "Song",    "000-111-222", new Test.HashCode("test11", 0)),
                      new Test(3, "Ma",      "000-111-222", new Test.HashCode("test12", 0)),
                  },
                  new List<Test>
                  {
                      new Test(4, "Kang",    "000-111-222", new Test.HashCode("test13", 0)),
                      new Test(5, "Lee",     "000-111-222", new Test.HashCode("test14", 0)),
                      new Test(6, "Kim",     "000-111-222", new Test.HashCode("test15", 0)),
                      new Test(7, "Han",     "000-111-222", new Test.HashCode("test16", 0)),
                  }
              }
          };

          Console.WriteLine(Dump.Write(test));
      }

      class Test
      {
          public long id;
          public string name;
          public string phone;
          public HashCode code;
          public Test(long id, string name, string phone, HashCode code)
          {
              this.id = id;
              this.name = name;
              this.phone = phone;
              this.code = code;
          }

          public class HashCode
          {
              public string from;
              public long serial;
              public HashCode(string from, long serial)
              {
                  this.from = from;
                  this.serial = serial;
              }
          }
      }
  }

  public class Dump
  {
      private int level;
      private int depth;
      private readonly int indent;
      private readonly StringBuilder logs;

      private Dump(int depth, int indent)
      {
          this.depth = depth;
          this.indent = indent;
          this.logs = new StringBuilder();
      }

      public static string Write(object element, int depth = 20, int indent = 2)
      {
          var dumper = new Dump(depth, indent);
          dumper.WriteLine("DUMPING...");
          dumper.WriteLine(element.GetType().FullName);
          return dumper.WriteElement(element);
      }

      private string WriteElement(object element)
      {
          try
          {
              if (element == null || element is ValueType || element is string)
              {
                  WriteLine(FormatValue(element));
              }
              else if (level < depth)
              {
                  var type = element.GetType();
                  if (typeof(IEnumerable).IsAssignableFrom(type) == false)
                  {
                      WriteLine("[{0}]", type.FullName);
                      level++;
                  }

                  var enumerable = element as IEnumerable;
                  if (enumerable != null)
                  {
                      WriteLine("...");

                      foreach (object item in enumerable)
                      {
                          if (item is IEnumerable && !(item is string))
                          {
                              if (level < depth)
                              {
                                  level++;
                                  WriteElement(item);
                                  level--;
                              }
                          }
                          else
                          {
                              WriteElement(item);
                          }
                      }
                  }
                  else
                  {
                      MemberInfo[] members = element.GetType().GetMembers(BindingFlags.Public | BindingFlags.Instance);
                      foreach (var member in members)
                      {
                          var f = member as FieldInfo;
                          var p = member as PropertyInfo;

                          if (f == null && p == null)
                              continue;

                          var t = (f != null) ? f.FieldType : p.PropertyType;
                          object v = (f != null) ? f.GetValue(element) : p.GetValue(element, null);

                          if (t.IsValueType || t == typeof(string))
                          {
                              WriteLine("{0}: {1}", member.Name, FormatValue(v));
                          }
                          else
                          {
                              WriteLine("{0}: {1}", member.Name, typeof(IEnumerable).IsAssignableFrom(t) ? "..." : "{ }");

                              if (level < depth)
                              {
                                  level++;
                                  WriteElement(v);
                                  level--;
                              }
                          }
                      }
                  }

                  if (typeof(IEnumerable).IsAssignableFrom(type) == false)
                  {
                      level--;
                  }
              }
          }
          catch (Exception e)
          {
              WriteLine("<ERROR>: {0}", e.HResult);
          }

          return logs.ToString();
      }

      private void WriteLine(string value, params object[] args)
      {
          var space = new string(' ', level * indent);

          if (args != null)
              value = string.Format(value, args);

          logs.AppendLine(space + value);
      }

      private string FormatValue(object o)
      {
          if (o == null)
              return ("null");

          if (o is DateTime)
              return (((DateTime)o).ToShortDateString());

          if (o is string)
              return string.Format("\"{0}\"", o);

          if (o is char && (char)o == '\0')
              return string.Empty;

          if (o is ValueType)
              return (o.ToString());

          if (o is IEnumerable)
              return ("...");

          return ("{ }");
      }
  }
  ```
  - ***See Also***
    - [***ObjectDumper***](https://gist.github.com/brentmaxwell/21d1f91f70c048593e57)


　

### HOOK UP A EVENT
---
- 이벤트 가로채기, 순서 바꾸기
```
using System;
using System.Reflection;
using System.Windows.Forms;
using System.ComponentModel;
 
class MyForm : Form
{
  public MyForm() : base()
  {
    this.Text = string.Empty;
    this.MouseClick += new MouseEventHandler(OnMouseClick1);
 
    ChangeEvent();
  }
 
  private void ChangeEvent()
  {
    var getEvents = this.GetType().GetMethod("get_Events", BindingFlags.NonPublic | BindingFlags.Instance);
    var events = getEvents.Invoke(this, new object[] { }) as EventHandlerList;
    var keyField = FindBaseType(typeof(Control)).GetField("EventMouseClick", BindingFlags.NonPublic | BindingFlags.Static);
    var key = keyField.GetValue(this);
    var oldEvent = events[key];
 
    // oldEvent.DynamicInvoke(this, null);
 
    events.RemoveHandler(key, oldEvent);
    events.AddHandler(key, new MouseEventHandler(OnMouseClick2));
    events.AddHandler(key, oldEvent);
  }
 
  private void OnMouseClick1(object sender, MouseEventArgs e)
  {
    this.Text += "0";
  }
 
  private void OnMouseClick2(object sender, MouseEventArgs e)
  {
    this.Text += "1";
  }
 
  private Type FindBaseType(Type type)
  {
    for (Type current = this.GetType().BaseType; current != null; current = current.BaseType)
    {
      if (current == type)
        return current;
    }
 
    return null;
  }
}
 
class Example
{
  public static void Main()
  {
    Application.Run(new MyForm());
  }
}
```
먼저 Control 내부 코드를 이해하는게 필요하다. .NET 소스코드 참고
Reflection.Emit을 사용한 event hooking은 여기를 참고.

- ***See Also***
  - ***https://m.blog.naver.com/dooyoun30/80116646985***
  - ***https://referencesource.microsoft.com/#q=control.cs***
  - [***How to: Hook Up a Delegate Using Reflection***](https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/how-to-hook-up-a-delegate-using-reflection)


　

실전예제 #4 - [RuntimeInitialzie] Attribute 구현
참고: 유니티에서 구현한 [InitializeOnLoad] 어트리뷰트

아래 예제는 [RuntimeInitialzie] Attribute를 사용한 모든 스태틱 함수를 어떻게 자동으로 호출할 수 있는지 보여준다.


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
public class RuntimeInitializeAttribute : Attribute
{
    public static void Initialize()
    {
        var methods = AppDomain
            .CurrentDomain
            .GetAssemblies()
            .SelectMany(x => x.GetTypes())
            .Where(x => x.IsClass)
            .SelectMany(x => x.GetMethods(BindingFlags.NonPublic | BindingFlags.Static))
            .Where(x => x.GetCustomAttributes(typeof(RuntimeInitializeAttribute), false).FirstOrDefault() != null);
 
        foreach (var method in methods)
            method.Invoke(null, null);
    }
}
 
public class Test
{
    [RuntimeInitialize]
    static void Initialize()
    {
        ....
    }
}
 
class Program
{
    static void Main(string[] args)
    {
        RuntimeInitializeAttribute.Initialize();
        ...
    }
}



실전예제 #5 - INotifyPropertyChanged Dynamic Proxy
참고: http://www.codewrecks.com/blog/index.php/2008/08/04/implement-inotifypropertychanged-with-dynamic-code-generation/

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.ComponentModel;
 
public class Example
{
  static void Main()
  {
    var customer = CreateProxy<Customer>();
    var notify = (INotifyPropertyChanged)customer;
 
    notify.PropertyChanged += delegate (Object sender, PropertyChangedEventArgs args)
    {
      Console.WriteLine("Property Changed:" + args.PropertyName);
    };
 
    customer.Property = "TEST";
    customer.AnotherProp = 111;
  }
 
  public class Customer
  {
    private String property;
    public virtual String Property
    {
      get { return property; }
      set { property = value; }
    }
 
    private Int32 anotherProp;
    public virtual Int32 AnotherProp
    {
      get { return anotherProp; }
      set { anotherProp = value; }
    }
  }
 
  static T CreateProxy<T>() where T : class, new()
    {
    var parent = typeof(T);
    var type = AppDomain
      .CurrentDomain
      .DefineDynamicAssembly(new AssemblyName("DynamicAssembly"), AssemblyBuilderAccess.Run)
      .DefineDynamicModule("DynamicModule")
      .DefineType
    (
      parent.Name + "Proxy",
      TypeAttributes.Public |
      TypeAttributes.Class |
      TypeAttributes.AutoClass |
      TypeAttributes.AnsiClass |
      TypeAttributes.BeforeFieldInit |
      TypeAttributes.AutoLayout,
      parent, new Type[] { typeof(INotifyPropertyChanged) }
    );
 
    type.AddInterfaceImplementation(typeof(INotifyPropertyChanged));
 
    var DelegateCombine = typeof(Delegate).GetMethod("Combine", new Type[] { typeof(Delegate), typeof(Delegate) });
    var DelegateRemove = typeof(Delegate).GetMethod("Remove", new Type[] { typeof(Delegate), typeof(Delegate) });
    var DelegateInvoke = typeof(PropertyChangedEventHandler).GetMethod("Invoke");
    var ProxyPropertyChanged = type.DefineField("PropertyChanged", typeof(PropertyChangedEventHandler), FieldAttributes.Private);
    var PropertyChangedEventArgs = typeof(PropertyChangedEventArgs).GetConstructor(new Type[] { typeof(String) });
 
    var AddPropertyChanged = type.DefineMethod(
      "add_PropertyChanged",
      MethodAttributes.Public |
      MethodAttributes.Virtual |
      MethodAttributes.SpecialName |
      MethodAttributes.Final |
      MethodAttributes.HideBySig |
      MethodAttributes.NewSlot,
      typeof(void),
      new Type[] { typeof(PropertyChangedEventHandler) });
 
    // STEP 1. generate add_PropertyChanged method code
    {
      var il = AddPropertyChanged.GetILGenerator();
      il.Emit(OpCodes.Ldarg_0);
      il.Emit(OpCodes.Ldarg_0);
      il.Emit(OpCodes.Ldfld, ProxyPropertyChanged);
      il.Emit(OpCodes.Ldarg_1);
      il.Emit(OpCodes.Call, DelegateCombine);
      il.Emit(OpCodes.Castclass, typeof(PropertyChangedEventHandler));
      il.Emit(OpCodes.Stfld, ProxyPropertyChanged);
      il.Emit(OpCodes.Ret);
    }
 
    var RemovePropertyChanged = type.DefineMethod(
      "remove_PropertyChanged",
      MethodAttributes.Public |
      MethodAttributes.Virtual |
      MethodAttributes.SpecialName |
      MethodAttributes.Final |
      MethodAttributes.HideBySig |
      MethodAttributes.NewSlot,
      typeof(void),
      new Type[] { typeof(PropertyChangedEventHandler) });
 
    // STEP 2. generate remove_PropertyChanged method code
    {
      var il = RemovePropertyChanged.GetILGenerator();
      il.Emit(OpCodes.Ldarg_0);
      il.Emit(OpCodes.Ldarg_0);
      il.Emit(OpCodes.Ldfld, ProxyPropertyChanged);
      il.Emit(OpCodes.Ldarg_1);
      il.Emit(OpCodes.Call, DelegateRemove);
      il.Emit(OpCodes.Castclass, typeof(PropertyChangedEventHandler));
      il.Emit(OpCodes.Stfld, ProxyPropertyChanged);
      il.Emit(OpCodes.Ret);
    }
 
    var OnPropertyChanged = type.DefineMethod(
      "OnPropertyChanged",
      MethodAttributes.Public,
      typeof(void),
      new Type[] { typeof(String) });
 
    // STEP 3. generate OnPropertyChanged method code
    {
      var il = OnPropertyChanged.GetILGenerator();
      var NULL = il.DefineLabel();
      il.DeclareLocal(typeof(PropertyChangedEventHandler));
      il.Emit(OpCodes.Nop);
      il.Emit(OpCodes.Ldarg_0);
      il.Emit(OpCodes.Ldfld, ProxyPropertyChanged);
      il.Emit(OpCodes.Stloc_0);
      il.Emit(OpCodes.Ldloc_0);
      il.Emit(OpCodes.Ldnull);
      il.Emit(OpCodes.Ceq);
      il.Emit(OpCodes.Brtrue, NULL);
      il.Emit(OpCodes.Ldloc_0);
      il.Emit(OpCodes.Ldarg_0);
      il.Emit(OpCodes.Ldarg_1);
      il.Emit(OpCodes.Newobj, PropertyChangedEventArgs);
      il.Emit(OpCodes.Callvirt, DelegateInvoke);
      il.MarkLabel(NULL);
      il.Emit(OpCodes.Ret);
    }
 
    // STEP 4. override all of base.Properties and calls OnPropertyChanged
    foreach (var property in parent.GetProperties(BindingFlags.Public | BindingFlags.Instance))
    {
      if (property.GetSetMethod().IsVirtual)
      {
        var pb = type.DefineProperty(property.Name, PropertyAttributes.None, property.PropertyType, Type.EmptyTypes);
        var get = type.DefineMethod(
          "get_" + property.Name,
          MethodAttributes.Public |
          MethodAttributes.SpecialName |
          MethodAttributes.HideBySig |
          MethodAttributes.Virtual,
          property.PropertyType,
          Type.EmptyTypes);
 
        var il = get.GetILGenerator();
        il.Emit(OpCodes.Ldarg_0);
        il.Emit(OpCodes.Call, property.GetGetMethod());
        il.Emit(OpCodes.Ret);
        pb.SetGetMethod(get);
 
        var set = type.DefineMethod(
          "set_" + property.Name,
          MethodAttributes.Public |
          MethodAttributes.SpecialName |
          MethodAttributes.HideBySig |
          MethodAttributes.Virtual,
          null,
          new Type[] { property.PropertyType });
 
        il = set.GetILGenerator();
        il.Emit(OpCodes.Ldarg_0);
        il.Emit(OpCodes.Ldarg_1);
        il.Emit(OpCodes.Call, property.GetSetMethod());
        il.Emit(OpCodes.Ldarg_0);
        il.Emit(OpCodes.Ldstr, property.Name);
        il.Emit(OpCodes.Call, OnPropertyChanged);
        il.Emit(OpCodes.Ret);
        pb.SetSetMethod(set);
      }
    }
 
    return Activator.CreateInstance(type.CreateType()) as T;
  }
}
WPF MVVM 구조에서 property 자동화 예제는 여기를 참고
MVVM이 뭔지 모르면 여기부터 보시던가.
Runtime weaving이라고도 부름


