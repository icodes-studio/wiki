1. TOOLS
ILDASM (IL Disassembler)

Ildasm.exe (IL Disassembler) - .NET Framework

Examples
ildasm [options] [PEfilename] [options]
ildasm myHello.exe
ildasm MyFile.exe /output:MyFile.il
ildasm MyFile.exe /text
ildasm /item:MyClass::MyMethod MyFile.exe /text
ildasm /item:"MyClass::MyMethod(instance void(int32,string)" MyFile.exe /text
ildasm /item:"MyClass::MyMethod(class [mscorlib]System.AppDomain(class [mscorlib]System.AppDomain)" MyFile.exe /text
ILASM (IL Assembler)

Ilasm.exe (IL Assembler) - .NET Framework

Examples
ilasm [options] filename [[options]filename...]
ilasm myTestFile
ilasm myTestFile /dll
ilasm myTestFile /dll /output:myNewTestFile.d
　

2. INotifyPropertyChanged weaver using Mono.Cecil
GitHub - Seng3694/IL-Code-Weaver-INotifyPropertyChanged-Example: Mono.Cecil IL Code Weaver Example

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using WEAVING;
 
namespace WPFAPP
{
  public class ViewModel : INotifyPropertyChanged
  {
    public event PropertyChangedEventHandler PropertyChanged;
 
    [NotifyPropertyChanged(typeof(TestModelComparer))]
    public TestModel TestModelProperty
    {
      get; set;
    }
 
    [NotifyPropertyChanged]
    public int TestIntProperty
    {
      get; set;
    }
 
    [NotifyPropertyChanged]
    public string TestStringProperty
    {
      get; set;
    }
 
    [NotifyPropertyChanged]
    public ObservableCollection<string> Log
    {
      get; set;
    }
 
    public ViewModel()
    {
      Log = new ObservableCollection<string>();
      PropertyChanged += OnPropertyChanged;
    }
 
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      Log.Add(e.PropertyName + ": " + this.GetType().GetProperty(e.PropertyName).GetValue(this));
      while (Log.Count > 100)
        Log.RemoveAt(0);
    }
  }
 
  public class TestModel
  {
    public int TestIntProperty
    {
      get; set;
    }
 
    public string TestStringProperty
    {
      get; set;
    }
  }
 
  public class TestModelComparer : IEqualityComparer<TestModel>
  {
    private static TestModelComparer comparer;
 
    public static TestModelComparer Default
    {
      get
      {
        if (comparer == null)
          comparer = new TestModelComparer();
 
        return comparer;
      }
    }
 
    private TestModelComparer()
    {
    }
 
    public bool Equals(TestModel x, TestModel y)
    {
      if (x == null && y == null)
        return true;
 
      if (x == null || y == null)
        return false;
 
      return
      (
        x.TestIntProperty == y.TestIntProperty &&
        x.TestStringProperty == y.TestStringProperty
      );
    }
 
    public int GetHashCode(TestModel obj)
    {
      return obj?.TestIntProperty.GetHashCode() ?? 0 + obj?.TestStringProperty.GetHashCode() ?? 0;
    }
  }
}
[NotifyPropertyChanged] attribute를 지정한 property는 backing field가 변경되었을 때 PropertyChanged event를 자동으로 발생시키는 것이 목적!
이전 강좌에서는 Dynamic Proxy를 만들어 runtime에 PropertyChanged를 자동화 했다. 여기서 살펴볼 Weaver는 compile된 .NET assembly 코드를 변조하여 새로운 property setter를 injection 하는 것이다.
Compile Time Weaving 이라고도 부름.
아래 NotifyPropertyChangedAttribute를 다른 project에 만들고 참조.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
using System;
 
namespace WEAVING
{
  public class NotifyPropertyChangedAttribute : Attribute
  {
    public Type ComparerType
    {
      get;
    }
 
    public NotifyPropertyChangedAttribute(Type comparerType = null)
    {
      ComparerType = comparerType;
    }
  }
}
이어서 만들 WEAVER TOOL은 WPF test project의 post build event에 추가되어 build된 assembly의 property setter를 변조하는 역할을 한다.
Reflection.Emit이 아닌 Mono.Cecil을 사용한다.
console application project로 만들자.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
using WEAVING;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
 
namespace WEAVER
{
  class Program
  {
    static void Main(string[] args)
    {
      try
      {
        Console.WriteLine(DateTime.Now + " start code weaving");
 
        var assembly = AssemblyDefinition.ReadAssembly(args[0], new ReaderParameters() { ReadSymbols = true });
        var custom = assembly.MainModule.Import(typeof(NotifyPropertyChangedAttribute));
        var eventArgs = assembly.MainModule.Import(typeof(PropertyChangedEventArgs));
        var eventArgsCtor = assembly.MainModule.Import(eventArgs.Resolve().Methods.First(m => m.Name == ".ctor"));
        var handler = assembly.MainModule.Import(typeof(PropertyChangedEventHandler));
        var handlerInvoke = assembly.MainModule.Import(handler.Resolve().Methods.First(m => m.Name == "Invoke"));
        var types = assembly.Modules.SelectMany(m => m.GetTypes());
        var customAttrName = typeof(NotifyPropertyChangedAttribute).FullName;
 
        var properties = types
          .SelectMany(t => t.Properties)
          .Where(p => p.CustomAttributes
          .Any(a => a.AttributeType.FullName == customAttrName));
 
        foreach (var property in properties)
        {
            var backingField = property.DeclaringType.Fields.First(f => f.Name == "<" + property.Name + ">k__BackingField");
            var propertyChanged = property.DeclaringType.Fields.First(f => f.Name == "PropertyChanged");
            var setter = property.SetMethod;
 
            MethodReference getDefault;
            MethodReference equals;
 
            var comparer = (TypeDefinition)property.CustomAttributes
              .First(a => a.AttributeType.FullName == customAttrName)
              .ConstructorArguments[0].Value;
 
            if (comparer == null)
            {
              var classType = assembly.MainModule.Import(typeof(EqualityComparer<>)).Resolve();
              var genericType = ((TypeReference)classType).MakeGenericInstanceType(property.PropertyType);
 
              getDefault = assembly.MainModule.Import(
                classType
                .Properties
                .First(m => m.Name == "Default")
                .GetMethod
                .MakeGenericMethod(genericType));
 
              equals = assembly.MainModule.Import(
                classType
                .Methods
                .First(m => m.Name == "Equals")
                .MakeGenericMethod(genericType));
            }
            else
            {
              getDefault = comparer.Methods.First(m => m.Name == "get_Default");
              equals = comparer.Methods.First(m => m.Name == "Equals");
            }
 
            setter.Body.Instructions.Clear();
 
            var il = setter.Body.GetILProcessor();
            var start = il.Create(OpCodes.Nop);
            var ret = il.Create(OpCodes.Ret);
            var ldarg_0_18 = il.Create(OpCodes.Ldarg_0);
            var ldarg_0_2b = il.Create(OpCodes.Ldarg_0);
 
            setter.Body.Instructions.Add(start);
            il.InsertAfter(start, ret);
            il.InsertBefore(ret, il.Create(OpCodes.Call, getDefault));
            il.InsertBefore(ret, il.Create(OpCodes.Ldarg_0));
            il.InsertBefore(ret, il.Create(OpCodes.Ldfld, backingField));
            il.InsertBefore(ret, il.Create(OpCodes.Ldarg_1));
            il.InsertBefore(ret, il.Create(OpCodes.Callvirt, equals));
            il.InsertBefore(ret, il.Create(OpCodes.Brfalse_S, ldarg_0_18));
            il.InsertBefore(ret, il.Create(OpCodes.Br_S, ret));
            il.InsertBefore(ret, ldarg_0_18);
            il.InsertBefore(ret, il.Create(OpCodes.Ldarg_1));
            il.InsertBefore(ret, il.Create(OpCodes.Stfld, backingField));
            il.InsertBefore(ret, il.Create(OpCodes.Ldarg_0));
            il.InsertBefore(ret, il.Create(OpCodes.Ldfld, propertyChanged));
            il.InsertBefore(ret, il.Create(OpCodes.Dup));
            il.InsertBefore(ret, il.Create(OpCodes.Brtrue_S, ldarg_0_2b));
            il.InsertBefore(ret, il.Create(OpCodes.Pop));
            il.InsertBefore(ret, il.Create(OpCodes.Br_S, ret));
            il.InsertBefore(ret, ldarg_0_2b);
            il.InsertBefore(ret, il.Create(OpCodes.Ldstr, property.Name));
            il.InsertBefore(ret, il.Create(OpCodes.Newobj, eventArgsCtor));
            il.InsertBefore(ret, il.Create(OpCodes.Callvirt, handlerInvoke));
            il.InsertBefore(ret, il.Create(OpCodes.Nop));
 
            var attributesToRemove = new List<CustomAttribute>();
 
            foreach (var attribute in property.CustomAttributes.Where(c => c.AttributeType.FullName == customAttrName))
              attributesToRemove.Add(attribute);
 
            foreach (var attribute in attributesToRemove)
              property.CustomAttributes.Remove(attribute);
        }
 
        assembly.Write(args[0], new WriterParameters() { WriteSymbols = true });
        Console.WriteLine(DateTime.Now + " code weaving finished");
      }
      catch (Exception ex)
      {
        Console.WriteLine(DateTime.Now + " code weaving failed");
        Console.WriteLine(ex.ToString());
      }
    }
  }
 
  public static class TypeReferenceExtensions
  {
    public static MethodReference MakeGenericMethod(this MethodReference self, TypeReference type)
    {
      var reference = new MethodReference(self.Name, self.ReturnType, type)
      {
        HasThis = self.HasThis,
        ExplicitThis = self.ExplicitThis,
        CallingConvention = self.CallingConvention
      };
 
      foreach (var parameter in self.Parameters)
        reference.Parameters.Add(new ParameterDefinition(parameter.ParameterType));
 
      foreach (var generic_parameter in self.GenericParameters)
        reference.GenericParameters.Add(new GenericParameter(generic_parameter.Name, reference));
 
      return reference;
    }
  }
}
위 프로그램 EXE를 WPF test project의 post build event로 등록하여 빌드 후 변조할수 있도록 하자.
"$(SolutionDir)WEAVER\bin\$(ConfigurationName)\WEAVER.exe" "$(TargetPath)" 이런 식으로...
That's it!
　

3. INotifyPropertyChanged weaver using Fody
GitHub - shenchauhan/Fody: A blog post on how to use Fody

GitHub - Fody/PropertyChanged: Injects INotifyPropertyChanged code into properties at compile time

어려우면 다른 사람이 만들어 놓은 자동화 플러그인을 사용해보자.
Fody라는 놈이 있다. 좀 전에 만들어 본 WEAVER.EXE가 하는 일을 예쁜 프레임워크 형태로 제공해주는 놈이다. 플러그인을 개발및 적용할 수 있는 환경을 제공한다고 하는 게 맞을라나?
PropertyChanged.Fody 라는 이름의 NuGet package가 있다.
Mono.Cecil을 사용하는 Fody 기반 플러그인이다.
설치하고 살펴보자.

PropertyChanged.Fody를 설치하고 빌드하면 output window에서 아래 메시지를 확인 할 수 있다.
MSBUILD : warning : Fody: Could not find a FodyWeavers.xml file at the project level (D:\RND#1\FODYTEST). A default file has been created. Please review the file and add it to your project.

xml파일이 없으면 아래 내용으로 solution 폴더 위치에 만들자.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
<?xml version="1.0" encoding="utf-8" ?>
<Weavers>
  <PropertyChanged/>
</Weavers>
준비 끝! 이제 사용해보자.
이번엔 UWP Application으로 test program을 만들어볼까?
아래는 MainPage.xml 내용
<Page
    x:Class="FODYTEST.MainPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:FODYTEST"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
 
    <StackPanel>
        <TextBlock Text="{x:Bind Person.FirstName}" />
        <TextBlock Text="{x:Bind Person.LastName}" />
        <TextBlock Text="{x:Bind Person.Age}" />
    </StackPanel>
</Page>

아래는 MainPage.cs 내용

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
using System.ComponentModel;
using Windows.UI.Xaml.Controls;
 
namespace FODYTEST
{
  public sealed partial class MainPage : Page
  {
    public MainPage()
    {
      this.InitializeComponent();
 
      Person.LastName = "KWAK";
    }
 
    public PersonWithFody Person
    {
      get; set;
    } = new PersonWithFody
    {
      Age = 21,
      FirstName = "STUDY",
      LastName = "CLASS"
    };
  }
 
  public class PersonWithFody : INotifyPropertyChanged
  {
    public event PropertyChangedEventHandler PropertyChanged;
 
    public int Age
    {
      get; set;
    }
 
    public string FirstName
    {
      get; set;
    }
 
    public string LastName
    {
      get; set;
    }
 
    private void OnLastNameChanged()
    {
      if (LastName == "KWAK")
        Age = 22;
    }
 
    private void OnPropertyChanged(string propertyName, object before, object after)
    {
      System.Diagnostics.Debug.WriteLine(
        "{0} has been changed to {1} from {2}",
        propertyName,
        after,
        before);
    }
  }
}
워메, 아름답지 않니?
[DoNotNotify] 를 사용하여 노티를 안 받을 수 있고
[PropertyChanged.AlsoNotifyFor] 로 다른 노티를 같이 발생시킬 수도 있다.
더 자세한 사용법은 여기를 참고
다음 세미나부터는 본격적으로 Unity3에서의 .NET Reflection 사용과 그 한계를 알아보고 IL2CPP 환경에서 돌아가는 IL Runtime을 만들수 있는지 알아보겠다.