### 6.1 Implement INotifyPropertyChanged with dynamic code generation
---
- 속성 통지(INotifyPropertyChanged) 기능을 동적으로 추가하기
- Runtime weaving이라고도 부름
    ```
    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.ComponentModel;

    public class Example
    {
        static void Main()
        {
            var customer = CreateProxy<Customer>();
            var notify = (INotifyPropertyChanged)customer;

            notify.PropertyChanged += delegate (Object sender, PropertyChangedEventArgs args)
            {
                Console.WriteLine("Property Changed:" + args.PropertyName);
            };

            customer.Property = "TEST";
            customer.AnotherProp = 111;
        }

        public class Customer
        {
            private String property;
            public virtual String Property
            {
                get { return property; }
                set { property = value; }
            }

            private Int32 anotherProp;
            public virtual Int32 AnotherProp
            {
                get { return anotherProp; }
                set { anotherProp = value; }
            }
        }

        static T CreateProxy<T>() where T : class, new()
        {
            var parent = typeof(T);
            var type = AssemblyBuilder
                .DefineDynamicAssembly(new AssemblyName("DynamicAssembly"), AssemblyBuilderAccess.Run)
                .DefineDynamicModule("DynamicModule")
                .DefineType
            (
                parent.Name + "Proxy",
                TypeAttributes.Public |
                TypeAttributes.Class |
                TypeAttributes.AutoClass |
                TypeAttributes.AnsiClass |
                TypeAttributes.BeforeFieldInit |
                TypeAttributes.AutoLayout,
                parent,
                new Type[] { typeof(INotifyPropertyChanged) }
            );

            type.AddInterfaceImplementation(typeof(INotifyPropertyChanged));

            var DelegateCombine = typeof(Delegate).GetMethod("Combine", new Type[] { typeof(Delegate), typeof(Delegate) });
            var DelegateRemove = typeof(Delegate).GetMethod("Remove", new Type[] { typeof(Delegate), typeof(Delegate) });
            var DelegateInvoke = typeof(PropertyChangedEventHandler).GetMethod("Invoke");
            var ProxyPropertyChanged = type.DefineField("PropertyChanged", typeof(PropertyChangedEventHandler), FieldAttributes.Private);
            var PropertyChangedEventArgs = typeof(PropertyChangedEventArgs).GetConstructor(new Type[] { typeof(String) });

            var AddPropertyChanged = type.DefineMethod(
                "add_PropertyChanged",
                MethodAttributes.Public |
                MethodAttributes.Virtual |
                MethodAttributes.SpecialName |
                MethodAttributes.Final |
                MethodAttributes.HideBySig |
                MethodAttributes.NewSlot,
                typeof(void),
                new Type[] { typeof(PropertyChangedEventHandler) });

            // STEP 1. generate add_PropertyChanged method code
            {
                var il = AddPropertyChanged.GetILGenerator();
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldfld, ProxyPropertyChanged);
                il.Emit(OpCodes.Ldarg_1);
                il.Emit(OpCodes.Call, DelegateCombine);
                il.Emit(OpCodes.Castclass, typeof(PropertyChangedEventHandler));
                il.Emit(OpCodes.Stfld, ProxyPropertyChanged);
                il.Emit(OpCodes.Ret);
            }

            var RemovePropertyChanged = type.DefineMethod(
                "remove_PropertyChanged",
                MethodAttributes.Public |
                MethodAttributes.Virtual |
                MethodAttributes.SpecialName |
                MethodAttributes.Final |
                MethodAttributes.HideBySig |
                MethodAttributes.NewSlot,
                typeof(void),
                new Type[] { typeof(PropertyChangedEventHandler) });

            // STEP 2. generate remove_PropertyChanged method code
            {
                var il = RemovePropertyChanged.GetILGenerator();
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldfld, ProxyPropertyChanged);
                il.Emit(OpCodes.Ldarg_1);
                il.Emit(OpCodes.Call, DelegateRemove);
                il.Emit(OpCodes.Castclass, typeof(PropertyChangedEventHandler));
                il.Emit(OpCodes.Stfld, ProxyPropertyChanged);
                il.Emit(OpCodes.Ret);
            }

            var OnPropertyChanged = type.DefineMethod(
                "OnPropertyChanged",
                MethodAttributes.Public,
                typeof(void),
                new Type[] { typeof(String) });

            // STEP 3. generate OnPropertyChanged method code
            {
                var il = OnPropertyChanged.GetILGenerator();
                var NULL = il.DefineLabel();
                il.DeclareLocal(typeof(PropertyChangedEventHandler));
                il.Emit(OpCodes.Nop);
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldfld, ProxyPropertyChanged);
                il.Emit(OpCodes.Stloc_0);
                il.Emit(OpCodes.Ldloc_0);
                il.Emit(OpCodes.Ldnull);
                il.Emit(OpCodes.Ceq);
                il.Emit(OpCodes.Brtrue, NULL);
                il.Emit(OpCodes.Ldloc_0);
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldarg_1);
                il.Emit(OpCodes.Newobj, PropertyChangedEventArgs);
                il.Emit(OpCodes.Callvirt, DelegateInvoke);
                il.MarkLabel(NULL);
                il.Emit(OpCodes.Ret);
            }

            // STEP 4. override all of base.Properties and calls OnPropertyChanged
            foreach (var property in parent.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                if (property.GetSetMethod().IsVirtual)
                {
                    var pb = type.DefineProperty(property.Name, PropertyAttributes.None, property.PropertyType, Type.EmptyTypes);
                    var get = type.DefineMethod(
                        "get_" + property.Name,
                        MethodAttributes.Public |
                        MethodAttributes.SpecialName |
                        MethodAttributes.HideBySig |
                        MethodAttributes.Virtual,
                        property.PropertyType,
                        Type.EmptyTypes);

                    var il = get.GetILGenerator();
                    il.Emit(OpCodes.Ldarg_0);
                    il.Emit(OpCodes.Call, property.GetGetMethod());
                    il.Emit(OpCodes.Ret);
                    pb.SetGetMethod(get);

                    var set = type.DefineMethod(
                        "set_" + property.Name,
                        MethodAttributes.Public |
                        MethodAttributes.SpecialName |
                        MethodAttributes.HideBySig |
                        MethodAttributes.Virtual,
                        null,
                        new Type[] { property.PropertyType });

                    il = set.GetILGenerator();
                    il.Emit(OpCodes.Ldarg_0);
                    il.Emit(OpCodes.Ldarg_1);
                    il.Emit(OpCodes.Call, property.GetSetMethod());
                    il.Emit(OpCodes.Ldarg_0);
                    il.Emit(OpCodes.Ldstr, property.Name);
                    il.Emit(OpCodes.Call, OnPropertyChanged);
                    il.Emit(OpCodes.Ret);
                    pb.SetSetMethod(set);
                }
            }
            return Activator.CreateInstance(type.CreateType()) as T;
        }
    }
    ```

- 원본 링크가 자꾸 깨져서 내용 가져옴 
    > - Andrea Saltarello, in his post of some days ago, told about POCO object and dynamic implementation of INotifyPropertyChanged.
    > - The problem is, how to implement INotifyPropertyChanged with dynamic code generation?
    > - The answer is that is quite simple even if we do not relay on Castle.DynamicProxy, here is a simple domain class.
    ```
    public class Customer
    {
        public virtual String Property
        {
            get { return property; }
            set { property = value; }
        }
        private String property;

        public virtual Int32 AnotherProp
        {
            get { return anotherProp; }
            set { anotherProp = value; }
        }
        private Int32 anotherProp;  
    }
    ```
    > - Now let’s see how you can create a dynamic type that inherits from it,
    > - and overrides all virtual properties implementing the INotifyPropertyChanged interface.
    > - The first step is to define the event PropertyChanged, so you need three methods,
    > - one for the add an event listener,
    > - the other for removing the event listener
    > - and the final one to raise the event.
    > - First step, create all the method info I’ll need for dynamic generation
    ```
    MethodInfo DelegateCombine = typeof(Delegate).GetMethod("Combine", new Type[] { typeof(Delegate), typeof(Delegate) });
    MethodInfo DelegateRemove = typeof(Delegate).GetMethod("Remove", new Type[] { typeof(Delegate), typeof(Delegate) });
    MethodInfo InvokeDelegate = typeof (PropertyChangedEventHandler).GetMethod("Invoke");
    FieldBuilder eventBack = mTypeBuilder.DefineField("PropertyChanged", typeof(PropertyChangingEventHandler), FieldAttributes.Private);
    ConstructorInfo CreateEventArgs = typeof (PropertyChangingEventArgs).GetConstructor(new Type[] {typeof (String)});
    ```

- ***See Also***
    - [***Implement INotifyPropertyChanged with dynamic code generation***](https://www.codewrecks.com/post/old/2008/08/implement-inotifypropertychanged-with-dynamic-code-generation/)
    - [***WPF INotifyPropertyChanged 구현 실습***](https://magpienote.tistory.com/52)


